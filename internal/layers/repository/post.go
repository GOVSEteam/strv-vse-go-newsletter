package repository

import (
	"context"
	"database/sql"
	"time"

	"github.com/GOVSEteam/strv-vse-go-newsletter/internal/models"
	"github.com/google/uuid"
	_ "github.com/lib/pq" // PostgreSQL driver
)

type PostRepository interface {
	CreatePost(ctx context.Context, post *models.Post) (uuid.UUID, error)
	GetPostByID(ctx context.Context, postID uuid.UUID) (*models.Post, error)
	ListPostsByNewsletterID(ctx context.Context, newsletterID uuid.UUID, limit int, offset int) ([]*models.Post, int, error)
	UpdatePost(ctx context.Context, post *models.Post) error
	DeletePost(ctx context.Context, postID uuid.UUID) error
	MarkPostAsPublished(ctx context.Context, postID uuid.UUID, publishedAt time.Time) error
}

type postgresPostRepository struct {
	db *sql.DB
}

func NewPostRepository(db *sql.DB) PostRepository {
	return &postgresPostRepository{db: db}
}

func (r *postgresPostRepository) CreatePost(ctx context.Context, post *models.Post) (uuid.UUID, error) {
	// Ensure created_at and updated_at are set if not already
	now := time.Now()
	if post.CreatedAt.IsZero() {
		post.CreatedAt = now
	}
	if post.UpdatedAt.IsZero() {
		post.UpdatedAt = now
	}
	// ID is generated by the DB if not provided, or use provided if it's a valid UUID
	if post.ID == uuid.Nil {
		post.ID = uuid.New() // Generate UUID if not set by DB default (though DB has DEFAULT gen_random_uuid())
	}

	query := `
		INSERT INTO posts (id, newsletter_id, title, content, published_at, created_at, updated_at)
		VALUES ($1, $2, $3, $4, $5, $6, $7)
		RETURNING id` // Return id to confirm, though we generate it or DB does

	var returnedID uuid.UUID
	err := r.db.QueryRowContext(ctx, query,
		post.ID, post.NewsletterID, post.Title, post.Content, post.PublishedAt, post.CreatedAt, post.UpdatedAt,
	).Scan(&returnedID)

	if err != nil {
		return uuid.Nil, err
	}
	return returnedID, nil
}

func (r *postgresPostRepository) GetPostByID(ctx context.Context, postID uuid.UUID) (*models.Post, error) {
	query := `
		SELECT id, newsletter_id, title, content, published_at, created_at, updated_at
		FROM posts
		WHERE id = $1`
	row := r.db.QueryRowContext(ctx, query, postID)

	var p models.Post
	err := row.Scan(&p.ID, &p.NewsletterID, &p.Title, &p.Content, &p.PublishedAt, &p.CreatedAt, &p.UpdatedAt)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil // Or a custom "not found" error
		}
		return nil, err
	}
	return &p, nil
}

func (r *postgresPostRepository) ListPostsByNewsletterID(ctx context.Context, newsletterID uuid.UUID, limit int, offset int) ([]*models.Post, int, error) {
	listQuery := `
		SELECT id, newsletter_id, title, content, published_at, created_at, updated_at
		FROM posts
		WHERE newsletter_id = $1
		ORDER BY created_at DESC
		LIMIT $2 OFFSET $3`
	rows, err := r.db.QueryContext(ctx, listQuery, newsletterID, limit, offset)
	if err != nil {
		return nil, 0, err
	}
	defer rows.Close()

	var posts []*models.Post
	for rows.Next() {
		var p models.Post
		if errScan := rows.Scan(&p.ID, &p.NewsletterID, &p.Title, &p.Content, &p.PublishedAt, &p.CreatedAt, &p.UpdatedAt); errScan != nil {
			return nil, 0, errScan
		}
		posts = append(posts, &p)
	}
	if err = rows.Err(); err != nil {
		return posts, 0, err
	}

	countQuery := `SELECT COUNT(*) FROM posts WHERE newsletter_id = $1`
	var totalCount int
	err = r.db.QueryRowContext(ctx, countQuery, newsletterID).Scan(&totalCount)
	if err != nil {
		// Depending on requirements, you might still return successfully fetched posts
		// or return an error for the whole operation.
		return posts, 0, err
	}

	return posts, totalCount, nil
}

func (r *postgresPostRepository) UpdatePost(ctx context.Context, post *models.Post) error {
	post.UpdatedAt = time.Now()
	query := `
		UPDATE posts
		SET title = $1, content = $2, published_at = $3, updated_at = $4
		WHERE id = $5`
	result, err := r.db.ExecContext(ctx, query, post.Title, post.Content, post.PublishedAt, post.UpdatedAt, post.ID)
	if err != nil {
		return err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rowsAffected == 0 {
		return sql.ErrNoRows // Or a custom error indicating not found or not updated
	}
	return nil
}

func (r *postgresPostRepository) DeletePost(ctx context.Context, postID uuid.UUID) error {
	query := `DELETE FROM posts WHERE id = $1`
	result, err := r.db.ExecContext(ctx, query, postID)
	if err != nil {
		return err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rowsAffected == 0 {
		return sql.ErrNoRows // Indicates post not found
	}
	return nil
}

func (r *postgresPostRepository) MarkPostAsPublished(ctx context.Context, postID uuid.UUID, publishedAt time.Time) error {
	updatedAt := time.Now()
	query := `
		UPDATE posts
		SET published_at = $1, updated_at = $2
		WHERE id = $3`
	result, err := r.db.ExecContext(ctx, query, publishedAt, updatedAt, postID)
	if err != nil {
		return err
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if rowsAffected == 0 {
		return sql.ErrNoRows // Post not found or already has that published_at value
	}
	return nil
}
